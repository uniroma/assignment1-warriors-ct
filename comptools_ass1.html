<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Computational Tools for Macroeconometrics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="comptools_ass1_files/libs/clipboard/clipboard.min.js"></script>
<script src="comptools_ass1_files/libs/quarto-html/quarto.js"></script>
<script src="comptools_ass1_files/libs/quarto-html/popper.min.js"></script>
<script src="comptools_ass1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="comptools_ass1_files/libs/quarto-html/anchor.min.js"></script>
<link href="comptools_ass1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="comptools_ass1_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="comptools_ass1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="comptools_ass1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="comptools_ass1_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="comptools_ass1.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Computational Tools for Macroeconometrics</h1>
<p class="subtitle lead">Assignment 1</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This assignment introduces students to practical and theoretical aspects of macroeconometrics, focusing on forecasting using the FRED-MD dataset. Students will learn to handle macroeconomic data, perform necessary transformations, apply univariate models to predict key economic indicators and to evaluate these forecasts.</p>
</section>
<section id="the-fred-md-dataset" class="level2">
<h2 class="anchored" data-anchor-id="the-fred-md-dataset">The FRED-MD dataset</h2>
<p>The FRED-MD dataset is a comprehensive monthly database for macroeconomic research compiled by the Federal Reserve Bank of St.&nbsp;Louis. It features a wide array of economic indicators. The list of economic indicators can be obtained from the paper accompanying the data <a href="">pdf</a>.</p>
<p>The data can be downloaded <a href="https://research.stlouisfed.org/econ/mccracken/fred-databases/">here</a>. The page contains all the different vintages of the data.</p>
<p>Let us start to download the <code>current.csv</code> file:</p>
<div id="e4fbe4ce" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co"># Load the dataset</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'~/Downloads/current.csv'</span>)</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co"># Clean the DataFrame by removing the row with transformation codes</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>df_cleaned <span class="op">=</span> df.drop(index<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-8"><a href="#cb1-8"></a>df_cleaned.reset_index(drop<span class="op">=</span><span class="va">True</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a>df_cleaned[<span class="st">'sasdate'</span>] <span class="op">=</span> pd.to_datetime(df_cleaned[<span class="st">'sasdate'</span>], <span class="bu">format</span><span class="op">=</span><span class="st">'%m/</span><span class="sc">%d</span><span class="st">/%Y'</span>)</span>
<span id="cb1-10"><a href="#cb1-10"></a>df_cleaned</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">sasdate</th>
<th data-quarto-table-cell-role="th">RPI</th>
<th data-quarto-table-cell-role="th">W875RX1</th>
<th data-quarto-table-cell-role="th">DPCERA3M086SBEA</th>
<th data-quarto-table-cell-role="th">CMRMTSPLx</th>
<th data-quarto-table-cell-role="th">RETAILx</th>
<th data-quarto-table-cell-role="th">INDPRO</th>
<th data-quarto-table-cell-role="th">IPFPNSS</th>
<th data-quarto-table-cell-role="th">IPFINAL</th>
<th data-quarto-table-cell-role="th">IPCONGD</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">DNDGRG3M086SBEA</th>
<th data-quarto-table-cell-role="th">DSERRG3M086SBEA</th>
<th data-quarto-table-cell-role="th">CES0600000008</th>
<th data-quarto-table-cell-role="th">CES2000000008</th>
<th data-quarto-table-cell-role="th">CES3000000008</th>
<th data-quarto-table-cell-role="th">UMCSENTx</th>
<th data-quarto-table-cell-role="th">DTCOLNVHFNM</th>
<th data-quarto-table-cell-role="th">DTCTHFNM</th>
<th data-quarto-table-cell-role="th">INVEST</th>
<th data-quarto-table-cell-role="th">VIXCLSx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1959-01-01</td>
<td>2583.560</td>
<td>2426.0</td>
<td>15.188</td>
<td>2.766768e+05</td>
<td>18235.77392</td>
<td>21.9665</td>
<td>23.3891</td>
<td>22.2688</td>
<td>31.7011</td>
<td>...</td>
<td>18.294</td>
<td>10.152</td>
<td>2.13</td>
<td>2.45</td>
<td>2.04</td>
<td>NaN</td>
<td>6476.00</td>
<td>12298.00</td>
<td>84.2043</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1959-02-01</td>
<td>2593.596</td>
<td>2434.8</td>
<td>15.346</td>
<td>2.787140e+05</td>
<td>18369.56308</td>
<td>22.3966</td>
<td>23.7048</td>
<td>22.4617</td>
<td>31.9337</td>
<td>...</td>
<td>18.302</td>
<td>10.167</td>
<td>2.14</td>
<td>2.46</td>
<td>2.05</td>
<td>NaN</td>
<td>6476.00</td>
<td>12298.00</td>
<td>83.5280</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1959-03-01</td>
<td>2610.396</td>
<td>2452.7</td>
<td>15.491</td>
<td>2.777753e+05</td>
<td>18523.05762</td>
<td>22.7193</td>
<td>23.8483</td>
<td>22.5719</td>
<td>31.9337</td>
<td>...</td>
<td>18.289</td>
<td>10.185</td>
<td>2.15</td>
<td>2.45</td>
<td>2.07</td>
<td>NaN</td>
<td>6508.00</td>
<td>12349.00</td>
<td>81.6405</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1959-04-01</td>
<td>2627.446</td>
<td>2470.0</td>
<td>15.435</td>
<td>2.833627e+05</td>
<td>18534.46600</td>
<td>23.2032</td>
<td>24.1927</td>
<td>22.9026</td>
<td>32.4374</td>
<td>...</td>
<td>18.300</td>
<td>10.221</td>
<td>2.16</td>
<td>2.47</td>
<td>2.08</td>
<td>NaN</td>
<td>6620.00</td>
<td>12484.00</td>
<td>81.8099</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1959-05-01</td>
<td>2642.720</td>
<td>2486.4</td>
<td>15.622</td>
<td>2.853072e+05</td>
<td>18679.66354</td>
<td>23.5528</td>
<td>24.3936</td>
<td>23.1231</td>
<td>32.5925</td>
<td>...</td>
<td>18.280</td>
<td>10.238</td>
<td>2.17</td>
<td>2.48</td>
<td>2.08</td>
<td>95.3</td>
<td>6753.00</td>
<td>12646.00</td>
<td>80.7315</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">776</td>
<td>2023-09-01</td>
<td>19111.748</td>
<td>15741.9</td>
<td>116.594</td>
<td>1.507530e+06</td>
<td>705304.00000</td>
<td>103.2096</td>
<td>101.0935</td>
<td>101.3665</td>
<td>102.1034</td>
<td>...</td>
<td>120.395</td>
<td>123.976</td>
<td>29.90</td>
<td>34.55</td>
<td>26.62</td>
<td>67.9</td>
<td>508808.61</td>
<td>913938.95</td>
<td>5074.6108</td>
<td>15.0424</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">777</td>
<td>2023-10-01</td>
<td>19145.402</td>
<td>15784.6</td>
<td>116.663</td>
<td>1.505477e+06</td>
<td>703528.00000</td>
<td>102.3722</td>
<td>100.5292</td>
<td>100.5527</td>
<td>101.1664</td>
<td>...</td>
<td>120.040</td>
<td>124.228</td>
<td>29.97</td>
<td>34.67</td>
<td>26.65</td>
<td>63.8</td>
<td>513229.64</td>
<td>918210.64</td>
<td>5015.5456</td>
<td>19.0462</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">778</td>
<td>2023-11-01</td>
<td>19213.108</td>
<td>15859.9</td>
<td>117.127</td>
<td>1.514733e+06</td>
<td>703336.00000</td>
<td>102.6710</td>
<td>100.9362</td>
<td>101.2159</td>
<td>101.8557</td>
<td>...</td>
<td>119.325</td>
<td>124.551</td>
<td>30.26</td>
<td>34.96</td>
<td>26.89</td>
<td>61.3</td>
<td>517434.30</td>
<td>922552.40</td>
<td>4999.7208</td>
<td>13.8563</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">779</td>
<td>2023-12-01</td>
<td>19251.946</td>
<td>15899.0</td>
<td>117.773</td>
<td>1.530296e+06</td>
<td>706180.00000</td>
<td>102.6715</td>
<td>100.8332</td>
<td>101.2843</td>
<td>101.9884</td>
<td>...</td>
<td>119.193</td>
<td>124.917</td>
<td>30.45</td>
<td>35.01</td>
<td>27.14</td>
<td>69.7</td>
<td>522366.13</td>
<td>928336.14</td>
<td>5077.4222</td>
<td>12.6960</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">780</td>
<td>2024-01-01</td>
<td>19377.558</td>
<td>15948.8</td>
<td>117.639</td>
<td>NaN</td>
<td>700291.00000</td>
<td>102.5739</td>
<td>100.9984</td>
<td>101.7258</td>
<td>102.6235</td>
<td>...</td>
<td>118.745</td>
<td>125.662</td>
<td>30.56</td>
<td>35.21</td>
<td>27.22</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>5105.3504</td>
<td>13.3453</td>
</tr>
</tbody>
</table>

<p>781 rows × 128 columns</p>
</div>
</div>
</div>
</div>
<div id="17f57416" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># Extract transformation codes</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>transformation_codes <span class="op">=</span> df.iloc[<span class="dv">0</span>, <span class="dv">1</span>:].to_frame().reset_index()</span>
<span id="cb2-3"><a href="#cb2-3"></a>transformation_codes.columns <span class="op">=</span> [<span class="st">'Series'</span>, <span class="st">'Transformation_Code'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The transformation codes map variables to the transformations we must apply to each variable to render them (approximately) stationary. The data frame <code>transformation_codes</code> has the variable’s name (<code>Series</code>) and its transformation (<code>Transformation_Code</code>). There are six possible transformations (<span class="math inline">\(x_t\)</span> denotes the variable to which the transformation is to be applied):</p>
<ul>
<li><code>transformation_code=1</code>: no trasformation</li>
<li><code>transformation_code=2</code>: <span class="math inline">\(\Delta x_t\)</span></li>
<li><code>transformation_code=3</code>: <span class="math inline">\(\Delta^2 x_t\)</span></li>
<li><code>transformation_code=4</code>: <span class="math inline">\(log(x_t)\)</span></li>
<li><code>transformation_code=5</code>: <span class="math inline">\(\Delta log(x_t)\)</span></li>
<li><code>transformation_code=6</code>: <span class="math inline">\(\Delta^2 log(x_t)\)</span></li>
<li><code>transformation_code=7</code>: <span class="math inline">\(\Delta (x_t/x_{t-1} - 1)\)</span></li>
</ul>
<p>We can apply these transformations using the following code:</p>
<div id="78074663" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2"></a></span>
<span id="annotated-cell-3-3"><a href="#annotated-cell-3-3"></a><span class="co"># Function to apply transformations based on the transformation code</span></span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4"></a><span class="kw">def</span> apply_transformation(series, code):</span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5"></a>    <span class="cf">if</span> code <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6"></a>        <span class="co"># No transformation</span></span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7"></a>        <span class="cf">return</span> series</span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8"></a>    <span class="cf">elif</span> code <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9"></a>        <span class="co"># First difference</span></span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10"></a>        <span class="cf">return</span> series.diff()</span>
<span id="annotated-cell-3-11"><a href="#annotated-cell-3-11"></a>    <span class="cf">elif</span> code <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="annotated-cell-3-12"><a href="#annotated-cell-3-12"></a>        <span class="co"># Second difference</span></span>
<span id="annotated-cell-3-13"><a href="#annotated-cell-3-13"></a>        <span class="cf">return</span> series.diff().diff()</span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14"></a>    <span class="cf">elif</span> code <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="annotated-cell-3-15"><a href="#annotated-cell-3-15"></a>        <span class="co"># Log</span></span>
<span id="annotated-cell-3-16"><a href="#annotated-cell-3-16"></a>        <span class="cf">return</span> np.log(series)</span>
<span id="annotated-cell-3-17"><a href="#annotated-cell-3-17"></a>    <span class="cf">elif</span> code <span class="op">==</span> <span class="dv">5</span>:</span>
<span id="annotated-cell-3-18"><a href="#annotated-cell-3-18"></a>        <span class="co"># First difference of log</span></span>
<span id="annotated-cell-3-19"><a href="#annotated-cell-3-19"></a>        <span class="cf">return</span> np.log(series).diff()</span>
<span id="annotated-cell-3-20"><a href="#annotated-cell-3-20"></a>    <span class="cf">elif</span> code <span class="op">==</span> <span class="dv">6</span>:</span>
<span id="annotated-cell-3-21"><a href="#annotated-cell-3-21"></a>        <span class="co"># Second difference of log</span></span>
<span id="annotated-cell-3-22"><a href="#annotated-cell-3-22"></a>        <span class="cf">return</span> np.log(series).diff().diff()</span>
<span id="annotated-cell-3-23"><a href="#annotated-cell-3-23"></a>    <span class="cf">elif</span> code <span class="op">==</span> <span class="dv">7</span>:</span>
<span id="annotated-cell-3-24"><a href="#annotated-cell-3-24"></a>        <span class="co"># Delta (x_t/x_{t-1} - 1)</span></span>
<span id="annotated-cell-3-25"><a href="#annotated-cell-3-25"></a>        <span class="cf">return</span> series.pct_change()</span>
<span id="annotated-cell-3-26"><a href="#annotated-cell-3-26"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-3-27"><a href="#annotated-cell-3-27"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Invalid transformation code"</span>)</span>
<span id="annotated-cell-3-28"><a href="#annotated-cell-3-28"></a></span>
<span id="annotated-cell-3-29"><a href="#annotated-cell-3-29"></a><span class="co"># Applying the transformations to each column in df_cleaned based on transformation_codes</span></span>
<span id="annotated-cell-3-30"><a href="#annotated-cell-3-30"></a><span class="cf">for</span> series_name, code <span class="kw">in</span> transformation_codes.values:</span>
<span id="annotated-cell-3-31"><a href="#annotated-cell-3-31"></a>    df_cleaned[series_name] <span class="op">=</span> apply_transformation(df_cleaned[series_name].astype(<span class="bu">float</span>), <span class="bu">float</span>(code))</span>
<span id="annotated-cell-3-32"><a href="#annotated-cell-3-32"></a></span>
<span id="annotated-cell-3-33"><a href="#annotated-cell-3-33"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1" onclick="event.preventDefault();" href="">1</a><span id="annotated-cell-3-34" class="code-annotation-target"><a href="#annotated-cell-3-34"></a>df_cleaned <span class="op">=</span> df_cleaned[<span class="dv">2</span>:]</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2" onclick="event.preventDefault();" href="">2</a><span id="annotated-cell-3-35" class="code-annotation-target"><a href="#annotated-cell-3-35"></a>df_cleaned.reset_index(drop<span class="op">=</span><span class="va">True</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="annotated-cell-3-36"><a href="#annotated-cell-3-36"></a>df_cleaned.head()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="34" data-code-annotation="1">Since some transformations induce missing values, we drop the first two observations of the dataset</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="35" data-code-annotation="2">We reset the index so that the first observation of the dataset has index 0</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display" data-execution_count="14">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">sasdate</th>
<th data-quarto-table-cell-role="th">RPI</th>
<th data-quarto-table-cell-role="th">W875RX1</th>
<th data-quarto-table-cell-role="th">DPCERA3M086SBEA</th>
<th data-quarto-table-cell-role="th">CMRMTSPLx</th>
<th data-quarto-table-cell-role="th">RETAILx</th>
<th data-quarto-table-cell-role="th">INDPRO</th>
<th data-quarto-table-cell-role="th">IPFPNSS</th>
<th data-quarto-table-cell-role="th">IPFINAL</th>
<th data-quarto-table-cell-role="th">IPCONGD</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">DNDGRG3M086SBEA</th>
<th data-quarto-table-cell-role="th">DSERRG3M086SBEA</th>
<th data-quarto-table-cell-role="th">CES0600000008</th>
<th data-quarto-table-cell-role="th">CES2000000008</th>
<th data-quarto-table-cell-role="th">CES3000000008</th>
<th data-quarto-table-cell-role="th">UMCSENTx</th>
<th data-quarto-table-cell-role="th">DTCOLNVHFNM</th>
<th data-quarto-table-cell-role="th">DTCTHFNM</th>
<th data-quarto-table-cell-role="th">INVEST</th>
<th data-quarto-table-cell-role="th">VIXCLSx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1959-03-01</td>
<td>0.006457</td>
<td>0.007325</td>
<td>0.009404</td>
<td>-0.003374</td>
<td>0.008321</td>
<td>0.014306</td>
<td>0.006035</td>
<td>0.004894</td>
<td>0.000000</td>
<td>...</td>
<td>-0.001148</td>
<td>0.000292</td>
<td>-0.000022</td>
<td>-0.008147</td>
<td>0.004819</td>
<td>NaN</td>
<td>0.004929</td>
<td>0.004138</td>
<td>-0.014792</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1959-04-01</td>
<td>0.006510</td>
<td>0.007029</td>
<td>-0.003622</td>
<td>0.019915</td>
<td>0.000616</td>
<td>0.021075</td>
<td>0.014338</td>
<td>0.014545</td>
<td>0.015650</td>
<td>...</td>
<td>0.001312</td>
<td>0.001760</td>
<td>-0.000022</td>
<td>0.012203</td>
<td>-0.004890</td>
<td>NaN</td>
<td>0.012134</td>
<td>0.006734</td>
<td>0.024929</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1959-05-01</td>
<td>0.005796</td>
<td>0.006618</td>
<td>0.012043</td>
<td>0.006839</td>
<td>0.007803</td>
<td>0.014955</td>
<td>0.008270</td>
<td>0.009582</td>
<td>0.004770</td>
<td>...</td>
<td>-0.001695</td>
<td>-0.001867</td>
<td>-0.000021</td>
<td>-0.004090</td>
<td>-0.004819</td>
<td>NaN</td>
<td>0.002828</td>
<td>0.002020</td>
<td>-0.015342</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1959-06-01</td>
<td>0.003068</td>
<td>0.003012</td>
<td>0.003642</td>
<td>-0.000097</td>
<td>0.009064</td>
<td>0.001141</td>
<td>0.007034</td>
<td>0.007128</td>
<td>-0.004767</td>
<td>...</td>
<td>0.003334</td>
<td>0.001946</td>
<td>-0.004619</td>
<td>0.003992</td>
<td>0.004796</td>
<td>NaN</td>
<td>0.009726</td>
<td>0.009007</td>
<td>-0.012252</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1959-07-01</td>
<td>-0.000580</td>
<td>-0.000762</td>
<td>-0.003386</td>
<td>0.012155</td>
<td>-0.000330</td>
<td>-0.024240</td>
<td>0.001168</td>
<td>0.008249</td>
<td>0.013054</td>
<td>...</td>
<td>-0.001204</td>
<td>-0.000013</td>
<td>0.000000</td>
<td>-0.004040</td>
<td>-0.004796</td>
<td>NaN</td>
<td>-0.004631</td>
<td>-0.001000</td>
<td>0.029341</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>5 rows × 128 columns</p>
</div>
</div>
</div>
</div>
<div id="2b659864" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="annotated-cell-4"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="1" onclick="event.preventDefault();" href="">1</a><span id="annotated-cell-4-1" class="code-annotation-target"><a href="#annotated-cell-4-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="annotated-cell-4-2"><a href="#annotated-cell-4-2"></a><span class="im">import</span> matplotlib.dates <span class="im">as</span> mdates</span>
<span id="annotated-cell-4-3"><a href="#annotated-cell-4-3"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="2" onclick="event.preventDefault();" href="">2</a><span id="annotated-cell-4-4" class="code-annotation-target"><a href="#annotated-cell-4-4"></a>series_to_plot <span class="op">=</span> [<span class="st">'INDPRO'</span>, <span class="st">'CPIAUCSL'</span>, <span class="st">'TB3MS'</span>]</span>
<span id="annotated-cell-4-5"><a href="#annotated-cell-4-5"></a>series_names <span class="op">=</span> [<span class="st">'Industrial Production'</span>,</span>
<span id="annotated-cell-4-6"><a href="#annotated-cell-4-6"></a>                <span class="st">'Inflation (CPI)'</span>,</span>
<span id="annotated-cell-4-7"><a href="#annotated-cell-4-7"></a>                <span class="st">'3-month Treasury Bill rate'</span>]</span>
<span id="annotated-cell-4-8"><a href="#annotated-cell-4-8"></a></span>
<span id="annotated-cell-4-9"><a href="#annotated-cell-4-9"></a></span>
<span id="annotated-cell-4-10"><a href="#annotated-cell-4-10"></a><span class="co"># Create a figure and a grid of subplots</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="3" onclick="event.preventDefault();" href="">3</a><span id="annotated-cell-4-11" class="code-annotation-target"><a href="#annotated-cell-4-11"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="bu">len</span>(series_to_plot), <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">15</span>))</span>
<span id="annotated-cell-4-12"><a href="#annotated-cell-4-12"></a></span>
<span id="annotated-cell-4-13"><a href="#annotated-cell-4-13"></a><span class="co"># Iterate over the selected series and plot each one</span></span>
<span id="annotated-cell-4-14"><a href="#annotated-cell-4-14"></a><span class="cf">for</span> ax, series_name, plot_title <span class="kw">in</span> <span class="bu">zip</span>(axs, series_to_plot, series_names):</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="4" onclick="event.preventDefault();" href="">4</a><span id="annotated-cell-4-15" class="code-annotation-target"><a href="#annotated-cell-4-15"></a>    <span class="cf">if</span> series_name <span class="kw">in</span> df_cleaned.columns:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="5" onclick="event.preventDefault();" href="">5</a><span id="annotated-cell-4-16" class="code-annotation-target"><a href="#annotated-cell-4-16"></a>        dates <span class="op">=</span> pd.to_datetime(df_cleaned[<span class="st">'sasdate'</span>], <span class="bu">format</span><span class="op">=</span><span class="st">'%m/</span><span class="sc">%d</span><span class="st">/%Y'</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="6" onclick="event.preventDefault();" href="">6</a><span id="annotated-cell-4-17" class="code-annotation-target"><a href="#annotated-cell-4-17"></a>        ax.plot(dates, df_cleaned[series_name], label<span class="op">=</span>plot_title)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="7" onclick="event.preventDefault();" href="">7</a><span id="annotated-cell-4-18" class="code-annotation-target"><a href="#annotated-cell-4-18"></a>        ax.xaxis.set_major_locator(mdates.YearLocator(base<span class="op">=</span><span class="dv">5</span>))</span>
<span id="annotated-cell-4-19"><a href="#annotated-cell-4-19"></a>        ax.xaxis.set_major_formatter(mdates.DateFormatter(<span class="st">'%Y'</span>))</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="8" onclick="event.preventDefault();" href="">8</a><span id="annotated-cell-4-20" class="code-annotation-target"><a href="#annotated-cell-4-20"></a>        ax.set_title(plot_title)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="9" onclick="event.preventDefault();" href="">9</a><span id="annotated-cell-4-21" class="code-annotation-target"><a href="#annotated-cell-4-21"></a>        ax.set_xlabel(<span class="st">'Year'</span>)</span>
<span id="annotated-cell-4-22"><a href="#annotated-cell-4-22"></a>        ax.set_ylabel(<span class="st">'Transformed Value'</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="10" onclick="event.preventDefault();" href="">10</a><span id="annotated-cell-4-23" class="code-annotation-target"><a href="#annotated-cell-4-23"></a>        ax.legend(loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="11" onclick="event.preventDefault();" href="">11</a><span id="annotated-cell-4-24" class="code-annotation-target"><a href="#annotated-cell-4-24"></a>        plt.setp(ax.xaxis.get_majorticklabels(), rotation<span class="op">=</span><span class="dv">45</span>, ha<span class="op">=</span><span class="st">'right'</span>)</span>
<span id="annotated-cell-4-25"><a href="#annotated-cell-4-25"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-4-26"><a href="#annotated-cell-4-26"></a>        ax.set_visible(<span class="va">False</span>)  <span class="co"># Hide plots for which the data is not available</span></span>
<span id="annotated-cell-4-27"><a href="#annotated-cell-4-27"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="12" onclick="event.preventDefault();" href="">12</a><span id="annotated-cell-4-28" class="code-annotation-target"><a href="#annotated-cell-4-28"></a>plt.tight_layout()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="13" onclick="event.preventDefault();" href="">13</a><span id="annotated-cell-4-29" class="code-annotation-target"><a href="#annotated-cell-4-29"></a>plt.show()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-4" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="1,2" data-code-annotation="1">We use library <code>matplotlib</code> to plot</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="4,5,6,7" data-code-annotation="2">We consider three series (<code>INDPRO</code>, <code>CPIAUCSL</code>, <code>TB3MS</code>) and assign them human-readable names (“Industrial Production”, “Inflation (CPI)”, “3-month Treasury Bill rate.”).</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="11" data-code-annotation="3">We create a figure with three (<code>len(series_to_plot)</code>) subplots arranged vertically. The figure size is 8x15 inches.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="15" data-code-annotation="4">We check if the series exists in each series <code>df_cleaned</code> DataFrame columns.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="16" data-code-annotation="5">We convert the <code>sasdate</code> column to <code>datetime</code> format (not necessary, since <code>sasdate</code> was converter earlier)</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="17" data-code-annotation="6">We plot each series against the <code>sasdate</code> on the corresponding subplot, labeling the plot with its human-readable name.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="18,19" data-code-annotation="7">We format the x-axis to display ticks and label the x-axis with dates taken every five years.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="20" data-code-annotation="8">Each subplot is titled with the name of the economic indicator.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="9">9</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="21,22" data-code-annotation="9">We label the x-axis “Year,” and the y-axis “Transformed Value,” to indicate that the data was transformed before plotting.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="10">10</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="23" data-code-annotation="10">A legend is added to the upper left of each subplot for clarity.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="11">11</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="24" data-code-annotation="11">We rotate the x-axis labels by 45 degrees to prevent overlap and improve legibility.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="12">12</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="28" data-code-annotation="12"><code>plt.tight_layout()</code> automatically adjusts subplot parameters to give specified padding and avoid overlap.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="13">13</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="29" data-code-annotation="13"><code>plt.show()</code> displays the figure with its subplots.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="comptools_ass1_files/figure-html/cell-5-output-1.png" width="758" height="1430" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="forecasting-in-time-series" class="level2">
<h2 class="anchored" data-anchor-id="forecasting-in-time-series">Forecasting in Time Series</h2>
<p>Forecasting in time series analysis involves using historical data to predict future values. The objective is to model the conditional expectation of a time series based on past observations.</p>
<section id="direct-forecasts" class="level3">
<h3 class="anchored" data-anchor-id="direct-forecasts">Direct Forecasts</h3>
<p>Direct forecasting involves modeling the target variable directly at the desired forecast horizon. Unlike iterative approaches, which forecast one step ahead and then use those forecasts as inputs for subsequent steps, direct forecasting directly models the relationship between past observations and future value.</p>
</section>
<section id="arx-models" class="level3">
<h3 class="anchored" data-anchor-id="arx-models">ARX Models</h3>
<p>Autoregressive Moving with predictors (ARX) models are a class of univariate time series models that extend ARMA models by incorporating exogenous (independent) variables. These models are formulated as follows:</p>
<p><span id="eq-model"><span class="math display">\[
\begin{aligned}
Y_{t+h} &amp;=  \alpha + \phi_0 Y_t + \phi_1 Y_{t-1} + \dots + \phi_p Y_{t-p} + \theta_{0,1} X_{t,1} + \theta_{1,1} X_{t-1,1} + \dots + \theta_{p,1} X_{t-p,1} + \dots + \theta_{0,k} X_{t,k} + \dots + \theta_{p,k} X_{t-p,k} + u_{t+h}\\
        &amp;=  \alpha + \sum_{i=0}^p \phi_i Y_{t-i} + \sum_{j=1}^k\sum_{s=0}^p \theta_{s,j} X_{t-s,j} + \epsilon_{t+h}
\end{aligned}
\tag{1}\]</span></span></p>
<ul>
<li><span class="math inline">\(Y_{t+h}\)</span>: The target variable at time <span class="math inline">\(t+h\)</span>.</li>
<li><span class="math inline">\(X_{t,j}\)</span>: Predictors (variable <span class="math inline">\(j=1,\ldots,k\)</span> at time <span class="math inline">\(t\)</span>).</li>
<li><span class="math inline">\(p\)</span> number of lags of the target and the predictors.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li>
<li><span class="math inline">\(\phi_i\)</span>, <span class="math inline">\(i=0,\dots,p\)</span>, and <span class="math inline">\(\theta_{j,s}\)</span>, <span class="math inline">\(j=1,\dots,k\)</span>, <span class="math inline">\(s=1,\ldots,r\)</span>: Parameters of the model.</li>
<li><span class="math inline">\(\epsilon_{t+h}\)</span>: error term.</li>
</ul>
<p>For instance, to predict Industrial Prediction using as predictor inflation and the 3-month t-bill, the target variable is <code>INDPRO</code>, and the predictors are <code>CPIAUSL</code> and <code>TB3MS</code>. Notice that the target and the predictors are the transformed variables. Thus, if we use <code>INDPRO</code> as the target, we are predicting the log-difference of industrial production, which is a good approximation for its month-to-month percentage change.</p>
<p>By convention, the data ranges from <span class="math inline">\(t=1,\ldots,T\)</span>, where <span class="math inline">\(T\)</span> is the last period, we have data (for the <code>df_cleaned</code> dataset, <span class="math inline">\(T\)</span> corresponds to January 2024).</p>
</section>
<section id="forecasting-with-arx" class="level3">
<h3 class="anchored" data-anchor-id="forecasting-with-arx">Forecasting with ARX</h3>
<p>Suppose that we know the parameters of the model for the moment. To obtain a forecast for <span class="math inline">\(Y_{T+h}\)</span>, the <span class="math inline">\(h\)</span>-step ahead forecast, we calculate <span class="math display">\[
\begin{aligned}
\hat{Y}_{T+h} &amp;=  \alpha + \phi_0 Y_T + \phi_1 Y_{T-1} + \dots + \phi_p Y_{T-p} \\
                  &amp;\,\,\quad \quad + \theta_{0,1} X_{T,1} + \theta_{1,1} X_{T-1,1} + \dots + \theta_{p,1} X_{T-p,1} \\
                  &amp;\,\,\quad \quad + \dots + \theta_{0,k} X_{T,k} + \dots + \theta_{p,k} X_{T-p,k}\\
        &amp;=  \alpha + \sum_{i=0}^p \phi_i Y_{T-i} + \sum_{j=1}^k\sum_{s=0}^p \theta_{s,j} X_{T-s,j}
\end{aligned}
\]</span></p>
<p>While this is conceptually easy, implementing the steps needed to calculate the forecast is insidious, and care must be taken to ensure we are calculating the correct forecast.</p>
<p>To start, it is convenient to rewrite the model in <a href="#eq-model" class="quarto-xref">Equation&nbsp;1</a> as a linear model <span class="math display">\[
\mathbf{y} = \mathbf{X}\boldsymbol{\beta} + \mathbf{u},
\]</span> where <span class="math inline">\(\boldsymbol{\beta}\)</span> is the vector (of size <span class="math inline">\(1+(1+p)(1+k)\)</span>) <span class="math display">\[
\boldsymbol{\beta}=\begin{pmatrix}\alpha\\
\phi_{0}\\
\vdots\\
\phi_{p}\\
\theta_{0,1}\\
\vdots\\
\theta_{p,1}\\
\vdots\\
\theta_{1,k}\\
\vdots\\
\theta_{p,k}
\end{pmatrix},
\]</span> <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{X}\)</span> are respectively given by <span class="math display">\[
\mathbf{y} = \begin{pmatrix}
y_{p+h+1}  \\
y_{p+h+2}\\
\vdots \\
y_{T}
\end{pmatrix}
\]</span> and <span class="math display">\[
\setcounter{MaxMatrixCols}{20}
\mathbf{X} = \begin{pmatrix}
    1      &amp; Y_{p+1}   &amp; Y_{p}     &amp; \cdots &amp; Y_{1}       &amp; X_{p+1,1}   &amp; X_{p,1}     &amp; \cdots &amp; X_{1,1}       &amp; \cdots &amp; X_{p+1,k}   &amp; X_{p,k}     &amp; \cdots &amp; X_{1,k}\\
    \vdots &amp; \vdots    &amp; \vdots    &amp;        &amp; \vdots      &amp; \vdots      &amp; \vdots      &amp;        &amp; \vdots        &amp; \cdots &amp; \vdots      &amp; \vdots      &amp;        &amp; \vdots \\
    1      &amp; Y_{T-h-1} &amp; Y_{T-h-2} &amp; \cdots &amp; Y_{T-h-p-1} &amp; X_{T-h-1,1} &amp; X_{T-h-2,1} &amp; \cdots &amp; X_{T-h-p-1,1} &amp; \cdots &amp; X_{T-h-1,k} &amp; X_{T-h-2,k} &amp; \cdots &amp; X_{T-h-p-1,k}\\
    1      &amp; Y_{T-h}   &amp; Y_{T-h-1} &amp; \cdots &amp; Y_{T-h-p}   &amp; X_{T-h,1}   &amp; X_{T-h-1,1} &amp; \cdots &amp; X_{T-h-p,1}   &amp; \cdots &amp;X_{T-h,k}   &amp; X_{T-h-1,k} &amp; \cdots &amp; X_{T-h-p,k} \\
\end{pmatrix}.
\]</span> The size of <span class="math inline">\(\mathbf{X}\)</span> is <span class="math inline">\((T-p-h)\times 1+(1+k)(1+p)\)</span> and that of <span class="math inline">\(\mathbf{y}\)</span> is <span class="math inline">\(T-h-p\)</span>.</p>
<p>The matrix <span class="math inline">\(\mathbf{X}\)</span> can be obtained in the following way:</p>
<div id="19ac62f3" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>Yraw <span class="op">=</span> df_cleaned[<span class="st">'INDPRO'</span>]</span>
<span id="cb3-2"><a href="#cb3-2"></a>Xraw <span class="op">=</span> df_cleaned[[<span class="st">'CPIAUCSL'</span>, <span class="st">'TB3MS'</span>]]</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>num_lags  <span class="op">=</span> <span class="dv">4</span>  <span class="co">## this is p</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>num_leads <span class="op">=</span> <span class="dv">1</span>  <span class="co">## this is h</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>X <span class="op">=</span> pd.DataFrame()</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">## Add the lagged values of Y</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>col <span class="op">=</span> <span class="st">'INDPRO'</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="cf">for</span> lag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,num_lags<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb3-10"><a href="#cb3-10"></a>        <span class="co"># Shift each column in the DataFrame and name it with a lag suffix</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>        X[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_lag</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> Yraw.shift(lag)</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="cf">for</span> col <span class="kw">in</span> Xraw.columns:</span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="cf">for</span> lag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,num_lags<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb3-15"><a href="#cb3-15"></a>        <span class="co"># Shift each column in the DataFrame and name it with a lag suffix</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>        X[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_lag</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> Xraw[col].shift(lag)</span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">## Add a column on ones (for the intercept)</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>X.insert(<span class="dv">0</span>, <span class="st">'Ones'</span>, np.ones(<span class="bu">len</span>(X)))</span>
<span id="cb3-19"><a href="#cb3-19"></a></span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="co">## X is now a DataFrame</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>X.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Ones</th>
<th data-quarto-table-cell-role="th">INDPRO_lag0</th>
<th data-quarto-table-cell-role="th">INDPRO_lag1</th>
<th data-quarto-table-cell-role="th">INDPRO_lag2</th>
<th data-quarto-table-cell-role="th">INDPRO_lag3</th>
<th data-quarto-table-cell-role="th">INDPRO_lag4</th>
<th data-quarto-table-cell-role="th">CPIAUCSL_lag0</th>
<th data-quarto-table-cell-role="th">CPIAUCSL_lag1</th>
<th data-quarto-table-cell-role="th">CPIAUCSL_lag2</th>
<th data-quarto-table-cell-role="th">CPIAUCSL_lag3</th>
<th data-quarto-table-cell-role="th">CPIAUCSL_lag4</th>
<th data-quarto-table-cell-role="th">TB3MS_lag0</th>
<th data-quarto-table-cell-role="th">TB3MS_lag1</th>
<th data-quarto-table-cell-role="th">TB3MS_lag2</th>
<th data-quarto-table-cell-role="th">TB3MS_lag3</th>
<th data-quarto-table-cell-role="th">TB3MS_lag4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.0</td>
<td>0.014306</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>-0.000690</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>0.10</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1.0</td>
<td>0.021075</td>
<td>0.014306</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>0.001380</td>
<td>-0.000690</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>0.15</td>
<td>0.10</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1.0</td>
<td>0.014955</td>
<td>0.021075</td>
<td>0.014306</td>
<td>NaN</td>
<td>NaN</td>
<td>0.001723</td>
<td>0.001380</td>
<td>-0.000690</td>
<td>NaN</td>
<td>NaN</td>
<td>-0.11</td>
<td>0.15</td>
<td>0.10</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1.0</td>
<td>0.001141</td>
<td>0.014955</td>
<td>0.021075</td>
<td>0.014306</td>
<td>NaN</td>
<td>0.000339</td>
<td>0.001723</td>
<td>0.001380</td>
<td>-0.00069</td>
<td>NaN</td>
<td>0.37</td>
<td>-0.11</td>
<td>0.15</td>
<td>0.10</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1.0</td>
<td>-0.024240</td>
<td>0.001141</td>
<td>0.014955</td>
<td>0.021075</td>
<td>0.014306</td>
<td>-0.001034</td>
<td>0.000339</td>
<td>0.001723</td>
<td>0.00138</td>
<td>-0.00069</td>
<td>-0.01</td>
<td>0.37</td>
<td>-0.11</td>
<td>0.15</td>
<td>0.1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p>Note that the first <span class="math inline">\(p=\)</span><code>4</code> rows of <code>X</code> have missing values.</p>
<p>The vector <span class="math inline">\(\mathbf{y}\)</span> can be similarly created as</p>
<div id="f76cdddb" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>y <span class="op">=</span> Yraw.shift(<span class="op">-</span>num_leads)</span>
<span id="cb4-2"><a href="#cb4-2"></a>y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>0      0.021075
1      0.014955
2      0.001141
3     -0.024240
4     -0.034465
         ...   
774   -0.008147
775    0.002915
776    0.000005
777   -0.000951
778         NaN
Name: INDPRO, Length: 779, dtype: float64</code></pre>
</div>
</div>
<p>The variable <code>y</code> has missing values in the last <code>h</code> positions (it is not possible to lead the target beyond <span class="math inline">\(T\)</span>).</p>
<p>Notice also that we must keep the last row of <code>X</code> for constructing the forecast.</p>
<p>Now we create two <code>numpy</code> arrays with the missing values stripped:</p>
<div id="358abd15" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">## Save last row of X (converted to numpy)</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>X_T <span class="op">=</span> X.iloc[<span class="op">-</span><span class="dv">1</span>:].values</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">## Subset getting only rows of X and y from p+1 to h-1</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">## and convert to numpy array</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>y <span class="op">=</span> y.iloc[num_lags:<span class="op">-</span>num_leads].values</span>
<span id="cb6-6"><a href="#cb6-6"></a>X <span class="op">=</span> X.iloc[num_lags:<span class="op">-</span>num_leads].values</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="119f78eb" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>X_T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>array([[ 1.00000000e+00, -9.51056709e-04,  4.86991246e-06,
         2.91450984e-03, -8.14668061e-03,  9.25729878e-04,
         7.21400503e-04,  7.26467817e-04,  8.11330254e-04,
        -2.79891559e-03, -1.51527417e-03, -2.00000000e-02,
        -3.00000000e-02, -7.00000000e-02,  2.00000000e-02,
         2.00000000e-02]])</code></pre>
</div>
</div>
<p>Now, we have to estimate the parameters and obtain the forecast.</p>
</section>
<section id="estimation" class="level3">
<h3 class="anchored" data-anchor-id="estimation">Estimation</h3>
<p>The parameters of the model can be estimated by OLS (the OLS estimates the coefficient of the linear projection of <span class="math inline">\(Y_{t+h}\)</span> on its lags and the lags of <span class="math inline">\(X_t\)</span>).</p>
<p>The OLS estimator of <span class="math inline">\(\boldsymbol{\beta}\)</span> is <span class="math display">\[
\hat{\boldsymbol{\beta}} = (X'X)^{-1}X'Y.
\]</span></p>
<p>While this is the formula used to describe the OLS estimator, from a computational poijnt of view is much better to define the estimator as the solution of the set of linear equations: <span class="math display">\[
(X'X)\boldsymbol{\beta} = X'Y
\]</span></p>
<p>The function <code>solve</code> can be used to solve this linear system of equation.</p>
<div id="2ab74c2b" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="im">from</span> numpy.linalg <span class="im">import</span> solve</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"># Solving for the OLS estimator beta: (X'X)^{-1} X'Y</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>beta_ols <span class="op">=</span> solve(X.T <span class="op">@</span> X, X.T <span class="op">@</span> y)</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co">## Produce the One step ahead forecast</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co">## % change month-to-month INDPRO</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>forecast <span class="op">=</span> X_T<span class="op">@</span>beta_ols<span class="op">*</span><span class="dv">100</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>forecast</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>array([0.08445815])</code></pre>
</div>
</div>
<p>The variable <code>forecast</code> contains now the one-step ahead (<span class="math inline">\(h=1\)</span> forecast) of <code>INDPRO</code>. Since <code>INDPRO</code> has been transformed in logarithmic differences, we are forecasting the percentage change (and multiplying by 100 gives the forecast in percentage points).</p>
<p>To obtain the <span class="math inline">\(h\)</span>-step ahead forecast, we must repeat all the above steps using a different <code>h</code>.</p>
</section>
<section id="forecasting-exercise" class="level3">
<h3 class="anchored" data-anchor-id="forecasting-exercise">Forecasting Exercise</h3>
<p>How good is the forecast that the model is producing? One thing we could do to assess the forecast’s quality is to wait for the new data on industrial production and see how big the forecasting error is. However, this evaluation would not be appropriate because we need to evaluate the forecast as if it were repeatedly used to forecast future values of the target variables. To properly assess the model and its ability to forecast <code>INDPRO</code>, we must keep producing forecasts and calculating the errors as new data arrive. This procedure would take time as we must wait for many months to have a series of errors that is large enough.</p>
<p>A different approach is to do what is called a Real-time evaluation. A Real-time evaluation procedure consists of putting ourselves in the shoes of a forecaster who has been using the forecasting model for a long time.</p>
<p>In practice, that is what are the steps to follow to do a Real-time evaluation of the model:</p>
<ol start="0" type="1">
<li><p>Set <span class="math inline">\(T\)</span> such that the last observation of <code>df</code> coincides with December 1999;</p></li>
<li><p>Estimate the model using the data up to <span class="math inline">\(T\)</span></p></li>
<li><p>Produce <span class="math inline">\(\hat{Y}_{T+1}, \hat{Y}_{T+2}, \dots, \hat{Y}_{T+H}\)</span></p></li>
<li><p>Since we have the actual data for January, February, …, we can calculate the forecasting errors of our model <span class="math display">\[
\hat{e}_{T+h} = \hat{Y}_{T+h} - Y_{T+h}, \,\, h = 1,\ldots, H.
\]</span></p></li>
<li><p>Set <span class="math inline">\(T = T+1\)</span> and do all the steps above.</p></li>
</ol>
<p>The process results are a series of forecasting errors we can evaluate using several metrics. The most commonly used is the MSFE, which is defined as <span class="math display">\[
MSFE_h = \frac{1}{J}\sum_{j=1}^J  \hat{e}_{T+j+h}^2,
\]</span> where <span class="math inline">\(J\)</span> is the number of errors we collected through our real-time evaluation.</p>
<p>This assignment asks you to perform a real-time evaluation assessment of our simple forecasting model and calculate the MSFE for steps <span class="math inline">\(h=1,4,8\)</span>.</p>
<p>As a bonus, we can evaluate different models and see how they perform differently. For instance, you might consider different numbers of lags and/or different variables in the model.</p>
<section id="hint" class="level4">
<h4 class="anchored" data-anchor-id="hint">Hint</h4>
<p>A sensible way to structure the code for real-time evaluation is to use several functions. For instance, you can define a function that calculates the forecast given the DataFrame.</p>
<div id="9d5e968f" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">def</span> calculate_forecast(df_cleaned, </span>
<span id="cb11-2"><a href="#cb11-2"></a>                       p <span class="op">=</span> <span class="dv">4</span>, </span>
<span id="cb11-3"><a href="#cb11-3"></a>                       H <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">8</span>], </span>
<span id="cb11-4"><a href="#cb11-4"></a>                       end_date <span class="op">=</span> <span class="st">'12/1/1999'</span>,</span>
<span id="cb11-5"><a href="#cb11-5"></a>                       target <span class="op">=</span> <span class="st">'INDPRO'</span>, </span>
<span id="cb11-6"><a href="#cb11-6"></a>                       xvars <span class="op">=</span> [<span class="st">'CPIAUCSL'</span>, <span class="st">'TB3MS'</span>]):</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="co">## Subset df_cleaned to use only data up to end_date</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    rt_df <span class="op">=</span> df_cleaned[df_cleaned[<span class="st">'sasdate'</span>] <span class="op">&lt;=</span> pd.Timestamp(end_date)]</span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="co">## Get the actual values of the target at different steps ahead</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    Y_actual <span class="op">=</span> []</span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="cf">for</span> h <span class="kw">in</span> H:</span>
<span id="cb11-12"><a href="#cb11-12"></a>        os <span class="op">=</span> pd.Timestamp(end_date) <span class="op">+</span> pd.DateOffset(months<span class="op">=</span>h)</span>
<span id="cb11-13"><a href="#cb11-13"></a>        Y_actual.append(df_cleaned[df_cleaned[<span class="st">'sasdate'</span>] <span class="op">==</span> os][target]<span class="op">*</span><span class="dv">100</span>)</span>
<span id="cb11-14"><a href="#cb11-14"></a>        <span class="co">## Now Y contains the true values at T+H (multiplying * 100)</span></span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a>    Yraw <span class="op">=</span> rt_df[target]</span>
<span id="cb11-17"><a href="#cb11-17"></a>    Xraw <span class="op">=</span> rt_df[xvars]</span>
<span id="cb11-18"><a href="#cb11-18"></a></span>
<span id="cb11-19"><a href="#cb11-19"></a>    X <span class="op">=</span> pd.DataFrame()</span>
<span id="cb11-20"><a href="#cb11-20"></a>    <span class="co">## Add the lagged values of Y</span></span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="cf">for</span> lag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,p):</span>
<span id="cb11-22"><a href="#cb11-22"></a>        <span class="co"># Shift each column in the DataFrame and name it with a lag suffix</span></span>
<span id="cb11-23"><a href="#cb11-23"></a>        X[<span class="ss">f'</span><span class="sc">{</span>target<span class="sc">}</span><span class="ss">_lag</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> Yraw.shift(lag)</span>
<span id="cb11-24"><a href="#cb11-24"></a></span>
<span id="cb11-25"><a href="#cb11-25"></a>    <span class="cf">for</span> col <span class="kw">in</span> Xraw.columns:</span>
<span id="cb11-26"><a href="#cb11-26"></a>        <span class="cf">for</span> lag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,p):</span>
<span id="cb11-27"><a href="#cb11-27"></a>            X[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_lag</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> Xraw[col].shift(lag)</span>
<span id="cb11-28"><a href="#cb11-28"></a>    </span>
<span id="cb11-29"><a href="#cb11-29"></a>    <span class="co">## Add a column on ones (for the intercept)</span></span>
<span id="cb11-30"><a href="#cb11-30"></a>    X.insert(<span class="dv">0</span>, <span class="st">'Ones'</span>, np.ones(<span class="bu">len</span>(X)))</span>
<span id="cb11-31"><a href="#cb11-31"></a>    </span>
<span id="cb11-32"><a href="#cb11-32"></a>    <span class="co">## Save the last row of X (converted to a `numpy` array)</span></span>
<span id="cb11-33"><a href="#cb11-33"></a>    X_T <span class="op">=</span> X.iloc[<span class="op">-</span><span class="dv">1</span>:].values</span>
<span id="cb11-34"><a href="#cb11-34"></a></span>
<span id="cb11-35"><a href="#cb11-35"></a>    <span class="co">## While the X will be the same, Y needs to be leaded differently</span></span>
<span id="cb11-36"><a href="#cb11-36"></a>    Yhat <span class="op">=</span> []</span>
<span id="cb11-37"><a href="#cb11-37"></a>    <span class="cf">for</span> h <span class="kw">in</span> H:</span>
<span id="cb11-38"><a href="#cb11-38"></a>        y_h <span class="op">=</span> Yraw.shift(<span class="op">-</span>h)</span>
<span id="cb11-39"><a href="#cb11-39"></a>        <span class="co">## Subset getting only rows of X and y from p+1 to h-1</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>        y <span class="op">=</span> y_h.iloc[p:<span class="op">-</span>h].values</span>
<span id="cb11-41"><a href="#cb11-41"></a>        X_ <span class="op">=</span> X.iloc[p:<span class="op">-</span>h].values</span>
<span id="cb11-42"><a href="#cb11-42"></a>        <span class="co"># Solving for the OLS estimator beta: (X'X)^{-1} X'Y</span></span>
<span id="cb11-43"><a href="#cb11-43"></a>        beta_ols <span class="op">=</span> solve(X_.T <span class="op">@</span> X_, X_.T <span class="op">@</span> y)</span>
<span id="cb11-44"><a href="#cb11-44"></a>        <span class="co">## Produce the One step ahead forecast</span></span>
<span id="cb11-45"><a href="#cb11-45"></a>        <span class="co">## % change month-to-month INDPRO</span></span>
<span id="cb11-46"><a href="#cb11-46"></a>        Yhat.append(X_T<span class="op">@</span>beta_ols<span class="op">*</span><span class="dv">100</span>)</span>
<span id="cb11-47"><a href="#cb11-47"></a></span>
<span id="cb11-48"><a href="#cb11-48"></a>    <span class="co">## Now calculate the forecasting error and return</span></span>
<span id="cb11-49"><a href="#cb11-49"></a></span>
<span id="cb11-50"><a href="#cb11-50"></a>    <span class="cf">return</span> np.array(Y_actual) <span class="op">-</span> np.array(Yhat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With this function, you can calculate real-time errors by looping over the <code>end_date</code> to ensure you end the loop at the right time.</p>
<div id="ed2b96de" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>t0 <span class="op">=</span> pd.Timestamp(<span class="st">'12/1/1999'</span>)</span>
<span id="cb12-2"><a href="#cb12-2"></a>e <span class="op">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3"></a>T <span class="op">=</span> []</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">10</span>):</span>
<span id="cb12-5"><a href="#cb12-5"></a>    t0 <span class="op">=</span> t0 <span class="op">+</span> pd.DateOffset(months<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="bu">print</span>(<span class="ss">f'Using data up to </span><span class="sc">{</span>t0<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb12-7"><a href="#cb12-7"></a>    ehat <span class="op">=</span> calculate_forecast(df_cleaned, p <span class="op">=</span> <span class="dv">4</span>, H <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">8</span>], end_date <span class="op">=</span> t0)</span>
<span id="cb12-8"><a href="#cb12-8"></a>    e.append(ehat.flatten())</span>
<span id="cb12-9"><a href="#cb12-9"></a>    T.append(t0)</span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="co">## Create a pandas DataFrame from the list</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>edf <span class="op">=</span> pd.DataFrame(e)</span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="co">## Calculate the RMSFE, that is, the square root of the MSFE</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>np.sqrt(edf.<span class="bu">apply</span>(np.square).mean())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Using data up to 2000-01-01 00:00:00
Using data up to 2000-02-01 00:00:00
Using data up to 2000-03-01 00:00:00
Using data up to 2000-04-01 00:00:00
Using data up to 2000-05-01 00:00:00
Using data up to 2000-06-01 00:00:00
Using data up to 2000-07-01 00:00:00
Using data up to 2000-08-01 00:00:00
Using data up to 2000-09-01 00:00:00
Using data up to 2000-10-01 00:00:00</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>0    0.337110
1    0.512690
2    0.624035
dtype: float64</code></pre>
</div>
</div>
<p>You may change the function <code>calculate_forecast</code> to output the actual data and the forecast so you can, for instance, construct a plot.</p>
</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Theoretically, the number of lags for the target variables and the predictors could be different. Here, we consider the simpler case in which both are equal.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>